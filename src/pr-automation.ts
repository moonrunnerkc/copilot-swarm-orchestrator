import * as path from 'path';
import ExternalToolManager from './external-tool-manager';
import { SwarmExecutionContext } from './swarm-orchestrator';
import { DeploymentMetadata } from './deployment-manager';

export interface PRSummary {
  title: string;
  body: string;
  baseBranch: string;
  headBranch: string;
}

/**
 * PR Automation - auto-creates PRs with execution summaries
 */
export class PRAutomation {
  private toolManager: ExternalToolManager;
  private workingDir: string;

  constructor(toolManager: ExternalToolManager, workingDir?: string) {
    this.toolManager = toolManager;
    this.workingDir = workingDir || process.cwd();
  }

  /**
   * Generate PR summary from execution context
   */
  generatePRSummary(
    context: SwarmExecutionContext,
    deployments: DeploymentMetadata[]
  ): PRSummary {
    const completedSteps = context.results.filter(r => r.status === 'completed').length;
    const failedSteps = context.results.filter(r => r.status === 'failed').length;
    const totalSteps = context.results.length;

    let body = '## Swarm Execution Summary\n\n';
    body += `**Execution ID:** \`${context.executionId}\`\n`;
    body += `**Goal:** ${context.plan.goal}\n`;
    body += `**Completed:** ${completedSteps}/${totalSteps} steps\n\n`;

    if (failedSteps > 0) {
      body += `‚ö†Ô∏è **${failedSteps} step(s) failed**\n\n`;
    }

    // Add deployment links
    if (deployments.length > 0) {
      body += '## üöÄ Preview Deployments\n\n';
      for (const deployment of deployments) {
        if (deployment.previewUrl) {
          body += `- **${deployment.platform}** (Step ${deployment.stepNumber}): ${deployment.previewUrl}\n`;
        }
      }
      body += '\n';
    }

    // Add step details
    body += '## Steps Executed\n\n';
    for (const result of context.results) {
      const icon = result.status === 'completed' ? '‚úÖ' : 
                   result.status === 'failed' ? '‚ùå' : 
                   result.status === 'running' ? 'üöß' : '‚è∏';
      
      body += `${icon} **Step ${result.stepNumber}** (${result.agentName}): ${result.status}\n`;
      
      if (result.verificationResult) {
        const passed = result.verificationResult.passed ? '‚úì' : '‚úó';
        body += `  - Verification: ${passed} ${result.verificationResult.passed ? 'passed' : 'failed'}\n`;
      }
    }

    body += '\n---\n';
    body += `*Generated by Copilot Swarm Orchestrator*\n`;

    return {
      title: `[Swarm] ${context.plan.goal}`,
      body,
      baseBranch: context.mainBranch,
      headBranch: `swarm/${context.executionId}`
    };
  }

  /**
   * Create PR via gh CLI
   */
  async createPR(summary: PRSummary): Promise<{ success: boolean; url?: string; error?: string }> {
    const tools = await this.toolManager.detectAvailableTools();
    
    if (!tools.gh) {
      return {
        success: false,
        error: 'gh CLI not available'
      };
    }

    // Create PR
    const execution = await this.toolManager.executeCommand(
      'gh',
      [
        'pr', 'create',
        '--base', summary.baseBranch,
        '--head', summary.headBranch,
        '--title', summary.title,
        '--body', summary.body
      ],
      {
        workingDir: this.workingDir,
        requireTool: 'gh'
      }
    );

    if (execution.exitCode !== 0) {
      return {
        success: false,
        error: execution.error || 'Failed to create PR'
      };
    }

    // Extract PR URL from output
    const url = this.extractPRUrl(execution.output || '');

    return {
      success: true,
      ...(url && { url })
    };
  }

  /**
   * Extract PR URL from gh CLI output
   */
  private extractPRUrl(output: string): string | undefined {
    const match = output.match(/(https:\/\/github\.com\/[^\s]+)/);
    return match ? match[1] : undefined;
  }
}

export default PRAutomation;
